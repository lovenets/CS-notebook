# HTTP 的安全缺陷

## 通信使用明文

HTTP 报文使用明文进行发送，加上互联网容易被窃听的特点，用 HTTP 传送的数据都存在着泄密的风险。

#### 1. 通信加密

将 HTTP 和 SSL 或 TLS 组合起来使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure）或者 HTTP over SSL。

### 2. 内容加密

客户端对 HTTP 报文进行加密处理后再发送请求。

## 不验证通信方的身份

HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应。

## 无法证明报文完整性

无法证明完整性意味着接收到的内容可能有误，可能被篡改。

# HTTPS

简单地讲，HTTPS = HTTP + 加密 + 认证 + 完整性保护。

## HTTPS 的混合加密机制

交换密钥环节使用非对称加密确保安全，交换报文环节使用对称加密提高速度。

## 证明公钥正确性的证书

为了保证公钥是正确的，可以使用由数字证书认证机构（CA, Certificate Authority）和其相关机构颁发的公开密钥证书。

CA 属于客户端和服务器端都信任的第三方机构，其运作流程如图：

![CA](img\CA.jpg)

### 证明组织的真实性：EV SSL 证书

证书除了要证明服务器是否规范，还要证明服务器背后的运营组织是否真实存在。这就是 EV SSL（Extended Validation SSL） 证书的作用。

### 确认客户端：客户端证书

HTTPS 中还可以使用客户端证书来认证客户端。但客户端证书存在一些问题：

（1）客户端证书要由用户自行安装，但是客户端证书是收费的。现阶段安全性极高的认证机构可向用户颁发证书但仅用于特殊业务。

（2）客户端证书只能证明客户端的真实性，并不能证明用户的合法性。

## HTTPS 的安全通信机制

![HTTPS 通信流程](img\HTTPS 通信流程.jpg)

### 通信步骤

1. 客户端通过发送 **Client Hello** 报文开始 SSL 通信，报文中包含了客户端支持的 SSL 版本、加密组件（Cipher Suite）列表(加密算法、密钥长度等)
2. 服务器可进行 SSL 通信时，会以 **Server Hello** 报文作为响应。报文也包含 SSL 版本和加密组件，服务器端的加密组件内容是从接收到的客户端加密组件内筛选出的。
3. 服务器发送 **Certificate** 报文，包含==公钥证书==
4. 服务器发送 **Server Hello Done** 报文通知客户端，最初的 SSL 握手协商部分结束。
5. SSL 第一次握手接手之后，客户端以 **Client Key Exchange** 报文作为回应，报文包含通信加密中使用的一种叫做 ==Pre-master secret== 的随机密码串，这个密码串已经经过公钥的加密
6. 客户端继续发送 **Change Cipher Spec** 报文，提示服务器再此保温之后的通信使用 Pre-master secret 密钥加密
7. 客户端发送 **Finished** 报文，报文包含连接至今全部报文的整体校验值。本次握手能否成功取决于服务器能否正确解密该报文。
8. 服务器发送 **Change Cipher Spec** 报文
9. 服务器发送 **Finished** 报文
10. 客户端和服务器完成 **Finished** 报文的交换之后，SSL 连接就算完成建立。通信受到 SSL 的保护，客户端开始发送 HTTP 请求
11. 服务器发送 HTTP 响应
12. 客户端断开连接时发送 **close_notify** 报文，之后还要发送 TCP FIN 报文来关闭 TCP 连接。

在以上流程中，发送数据时会附带一种叫做 MAC(Message Authentication Code)的摘要，用来校验报文的完整性。

### SSL 的速度

使用 SSL 时，HTTPS 的处理速度会变慢。

（1）通信慢。除开 TCP 连接、HTTP 请求和响应，还进行了 SSL 通信，整体上通信量不可避免地增加。

（2）处理速度慢。客户端和服务器都必须进行加密和解密的运算，因此会消耗更多的硬件资源。

技术上并没有根本性的解决方案，一般会使用 SSL 加速器来改善。

# 认证

## BAISC 认证

BASIC 认证是 HTTP/1.0 就定义的认证方法，十分简陋。

![BASIC 认证](img\BASIC 认证.jpg)

## DIGEST 认证

DIGEST 是 HTTP/1.1 定义的认证方法，从用质询码和响应码来进行认证。

![DIGEST 认证](img\DIGEST 认证.jpg)

和 BASIC 认证一样使用不便，而且不够安全，因此使用范围也受到较大限制。

## SSL 客户端认证

### 步骤

要使用 SSL 客户端认证，客户端就必须实现安装好证书。

1. 服务器接收到请求之后发送 Certificate Request 报文，要求客户端提供客户端证书。
2. 客户端将用户选择的证书以 Client Certificate 报文的方式发送给服务器
3. 服务器验证客户端证书，通过后领取证书内客户端的公钥，然后开始 HTTPS 加密通信。

### 双因素认证

SSL 在认证过程中不仅需要密码这一个因素，还需要申请认证方提供其他持有信息。第一个因素就是客户端证书，用来认证客户端计算机；第二个因素用来认证用户本人，一般是用户用表单提交的信息。

## 基于表单的认证

客户端向服务器上的 web 应用发送登录信息，按登录信息的验证结果认证。

HTTP 是无状态的，为了保存认证状态，一般使用 Cookie 来管理 Session。注意，这一点在 RFC 中并没有进行规定。

![表单认证](img\表单认证.jpg)

# 基于 HTTP 的协议

## SPDY

客户端为了实时获取更新的内容，需要持续向服务器发请求。这就会造成性能瓶颈。

Google 提出的  SPDY 协议目的在于能够在协议层面上消除 HTTP 的瓶颈。

### 设计

![SPDY](img\SPDY.jpg)

SPDY 没有完全改写 HTTP 协议，只是增加了一个会话层，以控制对数据的流动，但还是采用 HTTP 的通信方式。同时，考虑到安全性问题，规定使用 SSL。

### 功能

1. 多路复用：在一条 TCP 连接上无限制处理多个 HTTP 请求。
2. 赋予请求优先级：在发送多个请求时，为了解决因带宽低而导致响应变慢，给请求逐个分配优先级顺序。
3. 压缩 HTTP 首部：压缩报文首部，减少通信产生的数据包数量和发送的字节数。
4. 推送功能：支持服务器主动向客户端推送数据
5. 服务器提示：服务器可以主动提示客户端请求所需的资源。如果资源已经缓存，就不需要发送请求

### 缺陷

1. SPDY 基本上只是将单个域名的通信多路复用，当一个网站使用多个域名下的资源时改善效果有限。
2. 很多网站的问题并非完全是 HTTP 瓶颈所导致的。

## WebSocket

WebSocket 是客户端和服务器之间的全双工通信标准。

### 特点

1. 推送：服务器可以主动向客户端推送数据。
2. 减少通信量：只要建立起 WebSocket 连接就一直保持连接状态。WebSocket 首部信息很小，通信量也相应减少。

### 建立连接的流程

![WebSocket](img\WebSocket.jpg)

#### 1. 握手请求

```http
Upgrade: websocket
Sec-WebSocket-Key: dGhlIHNFDJSFHA==
Sec-WebSocket-Protocol: chat, superchat
```

`Upgrade`字段表示要切换为 WebSocket 协议，`Sec-WebSocket-Key`字段记录着握手过程中必需的键值，`Sec-WebSocket-Protocol`记录使用的子协议。

#### 2. 握手响应

```http
Upgrade: websocket
Sec-WebSocket-Accept: saflkdasdgsklj==
Sec-WebSocket-Protocol: chat
```

`Sec-WebSocket-Accept`的值是通过握手请求中`Sec-WebSocket-Key`字段的值计算生成的。















