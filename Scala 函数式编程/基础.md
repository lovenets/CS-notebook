# Scala 程序的基本结构

```scala
// object 用来声明一个单例模式的类
// 同时创建一个实例对象
object MyModule {
  // 参数是 Int，返回值是 Int
  def abs(n: Int): Int = { // 等号必需，花括号可选
    if (n < 0){
      -n  // 最后一条语句会自动 return
    } else {
      n
    }
  }

  // 私有方法只能在内部调用
  private def formatAbs(x: Int) = {  // 可以省略返回类型
    val msg ="The absolute value of %d is %d"  // 用 val 声明的就是常量
    msg.format(x,abs(x))  // 这条语句自动 return，所以程序推断出该函数返回值是 String
  }

  def main(args: Array[String]): Unit = {  // Unit 相当于 void
    println(formatAbs(-42))
  }
}
```

详解：

1. Scala 的函数被定义为返回等号右边表达式的值，所以在函数体中无需使用 `return`，不过为了可读性，最好还是显式声明函数的返回类型
2. 在 Scala 中如果用花括号包含了多条语句，那么这些语句所构成的代码块的返回值就是最后一个表达式的返回值
3. `Unit`和`void`类似，这种类型唯一的字面量写作`()`，通常返回`Unit`的方法暗示它包含副作用

# 模块、对象、命名空间

1. Scala 中的对象可以包含一个或多个成员，对象的作用就是给这些成员一个模块或者称为命名空间。引用对象的成员也是用`.`
2. 可以将一个对象的（非私有）成员导入到当前的作用域中：

```scala
import MyModule.abs
```

或者用下划线导入所有（非私有）成员：

```scala
import MyModule._
```

3. 注意，即使是`2+1`这样的表达式也是调用了成员，这个表达式调用了2的 + 方法。Scala 没有操作符的概念，完整的写法应该是`2.+(1)`。如果一个方法只有一个参数，那么可以省略`.`和`()`。

# 函数式编程的基本技巧

## 一、尾递归

纯函数式编程语言不允许用循环，因为循环明显是一个会改变状态的过程，所以在函数式编程中要用递归代替循环。

如果一个递归调用发生在函数的尾部，也就是说递归调用之后不做其他事情，那么编译器会把这种尾递归优化成为循环迭代，这样在每次迭代时就不必消耗栈帧的调用开销。

```scala
// 计算阶乘
def factorial(n: Int):Int = {
  // 定义一个局部函数
  // 函数内部的辅助递归函数通常称为 go 或者 loop
  def go(n:Int,acc:Int):Int = {
    if (n <= 0){
      acc
    } else{
      // 尾递归
      go(n - 1,n * acc)
    }
  }

  go(n,1)
}
```

可以在函数`go`上面加上注解`@tailrec`，这样做就会告诉编译器，如果尾递归的优化不成功的话就要报编译错误。

#### 习题：斐波那契数列尾递归实现

```scala
// 斐波那契数列
def fib_tailRec(n: Int): Int = {
  // 尾递归
  // a 就用来存储累加的结果
  def go(n: Int, a: Int, b: Int): Int = {
    if (n == 1) {
      a
    } else {
      go(n - 1, b, a + b)
    }
  }

  go(n, 0, 1)
}
```

![斐波那契数列尾递归](img\斐波那契数列尾递归.png)

## 二、高阶函数

在函数式编程语言中，如果一个函数可以接受函数作为参数，那么这种函数叫做高阶函数。

```scala
  // formatResult 是一个高阶函数，它接受一个函数 f 作为参数，f 以一个 Int 为参数并返回一个 Int
  private def formatResult(name: String, n: Int, f: Int => Int) = {
    val msg = "The %s of %d is %d"
    msg.format(name, n, f(n))
  }
```

对于高阶函数的参数，用 f 、g 或 h 来命名是一种习惯。

## 三、多态函数

如果高阶函数可以是任何类型的函数，那么这时的高阶函数被称为多态函数。

```scala
// 在数组中查找元素
// 类比 Java 中的泛型方法，T 就是泛型参数，Scala 是用中括号来表示泛型
def findFirst[T](arr: Array[T], p: T => Boolean): Int = {
  // 检验数组的第 n 个元素是不是要查找的元素
  def loop(n: Int): Int = {
    if (n >= arr.length) {
      -1
    } else if (p(arr(n))) { // 注意 Scala 用()来取数组元素
      n
    } else {
      loop(n + 1)
    }
  }

  loop(0)
}

// 如果第二个参数传入的是 lambda 表达式，注意要标明参数类型
println(findFirst(Array(1, 2, 3), (n: Int) => n == 3))
```

当把 lambda 表达式作为函数的参数传入时，要注意考虑程序能否从上下文推断出参数类型，如果可以，那么 lambda 表达式左边的参数类型符就可以省略。

```scala
// 明确指定类型参数为 Int，所以 lambda 表达式中无需再次指定
findFirst[Int](Array(1, 2, 3), n => n == 3)

// 没有指定类型参数，所以 lambda 表达式中要指定参数类型
findFirst(Array(1, 2, 3), (n: Int) => n == 3)
```

## 四、currying 柯里化

柯里化是指把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。

比如说现在有一个函数`(A,B) => C`，柯里化之后就会变成一个新函数`A => (B => C)`。

```scala
// 柯里化
def curry[A,B,C](f: (A,B) => C): A => (B => C) = {
  (a: A) => ((b: B) => f(a,b))
}

// 对 foo 进行柯里化并调用
def foo(x: Int,y: Int) : Int = x * x + y * y
curry(foo)(1)(2)
```

柯里化是一种处理函数中附有多个参数的方法，并在只允许单一参数的框架中使用这些函数。例如，一些分析技术只能用于具有单一参数的函数。现实中的函数往往有更多的参数。弗雷格表明，为单一参数情况提供解决方案已经足够了，因为可以将具有多个参数的函数转换为一个单参数的==函数链==。

如果需要的话，也可以反柯里化：

```scala
def uncurry[A, B, C](f: A => B => C): (A, B) => C = {
  (a: A, b: B) => f(a)(b)
}
```

## 五、复合函数

Scala 标准库中的`Functional1`（带有一个参数的函数接口）提供了`compose`和`andThen`方法，可以用来将两个只有一个参数的函数进行复合

- `f compose g` 等价于 `g andThen f`

```scala
// 函数复合
val foo = (x: Double) => x / 2.0
val bar = (x: Double) => math.sin(x)

val and = foo andThen bar
and(5.5)

val com = bar compose foo
com(5.5)
```

# 函数式数据结构

函数式数据结构是不可变的，比如说两个 list 相加可以得到另一个 list，但原来的两个 list 则没有发生变化。（list 相加写做 a ++ b）

## 一、定义数据类型

下面以 List 为例：

```scala
sealed trait List[+A]
case object Nil extends List[Nothing]
case class Cons[+A](head: A, tail: List[A]) extends List[A]

object List {
    def apply[A](as: A*): List[A] =  // 可变长参数的写法 
    	if (as.isEmpty) Nil
    	else Cons(as.head, apply(as.tail: _*))
}
```

详解：

1. 对于 Java 程序员来说，理解`traits`最简单的方法，是把它当作可以包含代码逻辑的接
   口（interface）。在 Scala 中，如果一个类继承自某个`trait`，则该类实现了`trait`的接
   口，并继承了`trait`的所有代码。

> `trait`和 Java 8 中的接口类似，class 和 object 都可以继承`trait`，但是 `trait`不能被实例化因此也就没有参数列表

2. `sealed`关键字表明`trait`的所有实现都必须在这个文件中

3. `case`关键字用来定义对不可变数据建模的类（类比 Kotlin 中的 data 类），`Cons`是数据构造器，用来构造非空的数据类型。当前版本的 Scala 已经不用 Cons 这种写法，定义构造器的话直接写作`[+A](head: A,tail: List[A])`

4. `object List`是`trait List`的伴生对象，可以理解为这个对象提供了用来创建或处理数据类型的方法。

5. `List[+A]`中的 + 表明 A 是协变的或正向的参数，比如说 Dog 是 Animal 的子类，那么`List[Dog]`是`List[Animal]`的子类。

## 二、模式匹配

```scala
def sum(ints: List[Int]): Int = ints match {
    case Nil => 0
    case Cons(x,xs) => x + sum(xs)
}
```

这是 List 的一个方法，用来计算 Int 型列表所有元素的和。其中用到了`match`表达式。

`match`和`switch`类似：

```scala
[ds] match {
    case [pattern] => [result]
}
```

`ds`是待匹配的值，每一条`case`语句的箭头左边称为模式，模式可以是普通的值（和其他语言中的`switch`一样），也可以是表达式；右边则是这种模式对应的结果。如果`ds`和多个模式匹配，那么 Scala 选择第一个匹配的。

### 1.默认匹配值

```scala
def matchTest(x: Int): String = x match {
  case 1 => "one"
  case 2 => "two"
  case _ => "many"
}
matchTest(3)  // many
matchTest(1)  // one
```

`_`下划线表示当其他项都不匹配时这一项匹配，相当于`switch`中的`default`。

### 2.匹配 case 类

```scala
// 定义一些 case 类
abstract class Notification

case class Email(sender: String, title: String, body: String) extends Notification

case class SMS(caller: String, message: String) extends Notification

case class VoiceRecording(contactName: String, link: String) extends Notification

// 匹配 case 类的构造
def showNotification(notification: Notification): String = {
  notification match {
    case Email(email, title, _) =>
      "You got an email from $email with title: $title"
    case SMS(number, message) =>
      "You got an SMS from $number! Message: $message"
    case VoiceRecording(name, link) =>
      "you received a Voice Recording from $name! Click the link to hear it: $link"
  }
}
val someSms = SMS("12345", "Are you there?")
val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")

println(showNotification(someSms))  //  You got an SMS from 12345! Message: Are you there?

println(showNotification(someVoiceRecording))  // you received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123
```

可以看到，当模式是表达式的时候，匹配结果表达式可以使用模式表达式中的参数。

### 3.匹配类型

```scala
abstract class Device
case class Phone(model: String) extends Device{
  def screenOff = "Turning screen off"
}
case class Computer(model: String) extends Device {
  def screenSaverOn = "Turning screen saver on..."
}

// 只是进行类型的匹配
def goIdle(device: Device) = device match {
  case p: Phone => p.screenOff
  case c: Computer => c.screenSaverOn
}
```

### 4.对 case 语句使用附加条件（守卫）

```scala
def showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {
  notification match {
      // 使用 if 语句进行附加判断
    case Email(email, _, _) if importantPeopleInfo.contains(email) =>
      "You got an email from special someone!"
    case SMS(number, _) if importantPeopleInfo.contains(number) =>
      "You got an SMS from special someone!"
  }
}

val importantPeopleInfo = Seq("867-5309", "jenny@gmail.com")

val someSms = SMS("867-5309", "Are you there?")

println(showImportantNotification(someSms, importantPeopleInfo))
```

## 三、数据共享

前面说过对 list 这种函数式数据结构的任何修改都会返回一个新的 list，但这个新的 list 并不是完全复制原来的 list，而是进行数据共享以提高效率。比如说向 list 中添加一个新的元素，那么新的 list 只有这一个新的元素，剩下的都是引用原来的 list。

函数式数据结构是持久的，这意味着已经存在的引用不会因为数据结构的操作而改变。

![数据共享](img\数据共享.jpg)

## 四、代数数据类型（Algebra Data Structure,ADT）

> ADT 是由一个或多个数据构造器所定义的数据类型，每个构造器可以包含零个或多个参数。数据类型是其数据构造器的累加或联合，每个数据构造器又是它的参数的乘积，故名代数数据类型

如果一个数据类型向外暴露的是可变状态，那么可能会导致无法预测的后果，但是函数式编程强调不变性。因此代数数据类型可以向外暴露自己的数据构造器。







