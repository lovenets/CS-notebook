# 数据结构

Scala 优先使用不可变的数据结构，如果想用可变的，需要导入：

```scala
import scala.collection.mutable._
```

## Map

### 一、构造

1.不可变 Map

```scala
val myMap = Map("Alice" -> 1, "Bob" -> 2, "Cindy" -> 3)
```

2.空 Map

```scala
val myMap2 = Map[String,Int]()
```

### 二、取值

```scala
myMap1("Alice")
```

如果要检查是否存在某个键值对：

```scala
val result = if (myMap1.contains("Alice")) myMap1("Alice") else 0
// 更简洁的写法
val result = myMap1.getOrElse("Alice",0)
```

可以给所有不存在的键都设置一个默认值：

```scala
val myMap3 = myMap1.withDefaultValue(0) // 默认值设为0
val myMap4 = myMap1.withDefault(_.length) // 默认值为键的字符串长度
```

### 三、更新值

Map 是不可变集合，如果要更新，实际上就是生成一个新的 Map

```scala
// 在 myMap1 的基础上，"Alice" 对应的值被更新，同时新增一个键值对
val myMap5 = myMap1 + ("Alice" -> 2,"Anderson" -> 8)
// 在 myMap1 的基础上减去 "Alice" 键值对
val myMap6 = myMap1 - "Alice"
```

### 四、迭代

```scala
val myMap7 = for ((k,v) <- myMap1) yield v -> k  // 反转 key 和 value
```

## Tuple

### 一、构造

```scala
val myTuple = (1,2,"Alice",10.5)
```

### 二、取值

```scala
myTuple._1
```

## List

在 Scala 中，非空的 List 总是一个 head 元素加上一个列表（称为 tail）。

### 一、构造

```scala
val myList = List(1,2,3)
myList.head  // 1
myList.tail  // List(2, 3)
```

还可以用`::`操作符创建 List：

```scala
val myList1 = 9 :: List(2,4) // List(9, 2, 4)
val myList2 = 1 :: 2 :: 3 :: Nil // List(1, 2, 3)
```

### 二、迭代

使用递归来迭代 List：

```scala
// 输出 List 的每一个元素
def printList(list: List[Int]): Unit = {
  if (list == Nil){
    println("Nil")
  } else {
    println(list.head)
    printList(list.tail)
  }
}
```

当然类库已经有封装好的方法，一般无需手动迭代。

```scala
myList1.foreach(println)
```

## Set

### 一、构造

```scala
val mySet1 = Set(1,2,3)
val mySet2 = mySet1 + 3  // 1,2,3
```

### 二、集合运算

```scala
mySet1 contains 0  // 是否包含某个元素
mySet1.subsetOf(mySet2)  // 是否为另一个 Set 的子集
val unionSet = mySet1 union mySet2  // 并集
val intersectSet = mySet1 intersect mySet2  // 交集
val diffSet = mySet1 diff mySet2  // 差集
```

## 集合操作

### 一、map

映射就是将一个集合变为另一个集合。

（1）`map`

```scala
val names = List("Peter","Anderson","Mary")
names.map(_.toUpperCase)  // List(PETER, ANDERSON, MARY)
```

（2）`flatMap`

这个方法和`map`的区别在于，`map`用于将一个一个的==值==组合成为集合，而`flatMap`将一个一个的==集合==组合为一个大的集合：

```scala
def ulcase(s: String) = List(s.toUpperCase,s.toLowerCase)  // 返回的是 List
names.flatMap(ulcase)  // List(PETER, peter, ANDERSON, anderson, MARY, mary)
```

### 二、collect

`collect`方法用于偏函数。

> 偏函数最大的特点就是它只接受和处理其参数定义域的一个子集，而对于这个子集之外的参数则抛出运行时异常。这与 case 语句的特性非常契合，case 语句常常是匹配一组具体的模式，最后用“_”来代表剩余的模式。如果一组 case 语句没有涵盖所有的情况，那么这组case语句就可以被看做是一个偏函数。

```scala
// 如果要使用语句的话就要用花括号将语句包围起来
"-65+5".collect { case '+' => 1; case '-' => -1}  // Vector(-1, 1)
```

上面这个例子中传递给`collect`的函数只处理了'+'和'-'的情况，没有覆盖所有的可能，所以是一个偏函数。

### 三、groupBy

用于分组操作，返回的结果是一个 Map，接受的参数用来生成键：

```scala
val names = List("Peter","Anderson","Mary")
names.groupBy(_.charAt(0).toUpper)  // Map(M -> List(Mary), P -> List(Peter), A -> List(Anderson))
```

### 四、reduce

`reduce`操作的原理如下：

![reduce](img\reduce.jpg)

op 是对相邻两个元素所作的操作。方法签名：

```scala
def reduce[A1 >: A](op: (A1, A1) ⇒ A1): A1
```

```scala
val myList = List(1,2,3,4)
myList.reduce(_+_)  // 10
```

### 五、fold

![fold](img\fold.jpg)

方法签名：

```scala
def fold[A1 >: A](z: A1)(op: (A1, A1) ⇒ A1): A1
```

```scala
val myList = List(1,2,3,4)
myList.fold(10)(_+_)  // 20
```

### 六、scan

将`scan`理解为`reduce`和`fold`的结合，方法签名：

```scala
def scan[B >: A, That](z: B)(op: (B, B) ⇒ B)(implicit cbf: CanBuildFrom[Repr, B, That]): That
```

```scala
val myList = List(1,2,3,4)
myList.scan(0)(_+_)  // List(0, 1, 3, 6, 10)
```

### 七、zip

`zip`将两个集合对应位置上的元素组合起来变成 Tuple：

```scala
val names = List("Peter","Anderson","Mary")
val myList = List(1,2,3,4)
myList.zip(names)  // List((1,Peter), (2,Anderson), (3,Mary))
```

如果一个集合比另一个集合短，那么结果中的 Tuple 数量和较短集合的元素数量相同。

### 八、并行

简单了解一下，集合的某些操作是支持并行化的：

```scala
myList.par.sum  // 并行求和
```

调用`par`的时候首先得到一个支持并行操作的集合类型，注意这些结合类型并不是普通集合类型的子类。如果需要，可以转换回普通集合类型：

```scala
val result = myList.par.filter(_ % 2 == 0).seq  // Vector(2, 4)
```

# 模式匹配

`match`和`switch`类似：

```scala
[ds] match {
    case [pattern] => [result]
}
```

`ds`是待匹配的值，每一条`case`语句的箭头左边称为模式，模式可以是普通的值（和其他语言中的`switch`一样），也可以是表达式；右边则是这种模式对应的结果。如果`ds`和多个模式匹配，那么 Scala 选择第一个匹配的。

## 默认匹配值

```scala
def matchTest(x: Int): String = x match {
  case 1 => "one"
  case 2 => "two"
  case _ => "many"
}
matchTest(3)  // many
matchTest(1)  // one
```

`_`下划线表示当其他项都不匹配时这一项匹配，相当于`switch`中的`default`。

## 匹配 case 类

case 类是一种特殊的类，经过优化之后用于模式匹配。

```scala
// 定义一些 case 类
abstract class Notification

case class Email(sender: String, title: String, body: String) extends Notification

case class SMS(caller: String, message: String) extends Notification

case class VoiceRecording(contactName: String, link: String) extends Notification

// 匹配 case 类的构造
def showNotification(notification: Notification): String = {
  notification match {
    case Email(email, title, _) =>
      "You got an email from email with title: title"
    case SMS(number, message) =>
      "You got an SMS from number! Message: message"
    case VoiceRecording(name, link) =>
      "you received a Voice Recording from name! Click the link to hear it: link"
  }
}
val someSms = SMS("12345", "Are you there?")
val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")

println(showNotification(someSms))  //  You got an SMS from 12345! Message: Are you there?

println(showNotification(someVoiceRecording))  // you received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123

```

可以看到，当模式是表达式的时候，匹配结果表达式可以使用模式表达式中的参数。

## 匹配类型

```scala
abstract class Device
case class Phone(model: String) extends Device{
  def screenOff = "Turning screen off"
}
case class Computer(model: String) extends Device {
  def screenSaverOn = "Turning screen saver on..."
}

// 只是进行类型的匹配
def goIdle(device: Device) = device match {
  case p: Phone => p.screenOff
  case c: Computer => c.screenSaverOn
}
```

## 对 case 语句使用附加条件（守卫）

```scala
def showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {
  notification match {
      // 使用 if 语句进行附加判断
    case Email(email, _, _) if importantPeopleInfo.contains(email) =>
      "You got an email from special someone!"
    case SMS(number, _) if importantPeopleInfo.contains(number) =>
      "You got an SMS from special someone!"
  }
}

val importantPeopleInfo = Seq("867-5309", "jenny@gmail.com")

val someSms = SMS("867-5309", "Are you there?")

println(showImportantNotification(someSms, importantPeopleInfo))

```

# 高阶函数

## 将函数作为值

```scala
val foo = (_: String).charAt(_: Int)

val bar: (String, Int) => Char = _.charAt(_)
```

赋值符号的两边至少要有一边指明函数的类型。

## 匿名函数

```scala
Array(3.14,1.42,2.0).map((_: Double) => 3 * _)

Array(3.14,1.42,2.0) map {(_: Double) => 3 * _} // 使用中缀表达式的时候经常使用花括号
```

## 高阶函数的类型推断

```scala
def valueAtOneQuarter(f: (Double) => Double) = f(0.25)

valueAtOneQuarter((x: Double) => 3 * x)
valueAtOneQuarter((x) => 3 * x )  // 因为 valueAtOneQuarter 在定义时已经给出了类型，所以可以省略
valueAtOneQuarter(x => 3 * x)  // 只有一个参数时可以省略圆括号
valueAtOneQuarter(3 * _)  // 如果参数只使用一次，那么可以用下划线代替
```

## 常用的高阶函数

### 1.map

### 2.filter

### 3.foreach

### 4.reduce

### 5.sortWith

```scala
val str = "Mary had a little lamb"
// 按长度升序排序每个单词
str.split(" ").sortWith(_.length < _.length) // Array(a, had, Mary, lamb, little)
```

## 闭包

```scala
def mulBy(factor: Double) = (x: Double) => x * factor
val triple = mulBy(3)  // factor 为 3
val half = mulBy(0.5)  // factor 为 0.5
println(s"${triple(14)} ${half(5)}")  // 42.0 2.5
```

`mulBy`会返回一个匿名函数，第一次调用`mulBy`的时候这个匿名函数内部的`factor`为3；第二次调用`mulBy`的时候返回另一个匿名函数，内部的`factor`为0.5。这种匿名函数叫做闭包，闭包由代码和代码用到的任何非局部变量构成。

## 柯里化

以两个接受两个参数的函数为例，柯里化指的是将原来接受两个参数的函数转变为新的接受一个参数的函数，这个新的函数返回一个以原有第二个参数作为参数的函数。

```scala
val mul = (x:Int,y:Int) => x * y
// 柯里化
val mulOneAtATime = (x: Int) => ((y: Int) => x * y)
mulOneAtATime(2)(3)
```

如果用`def`进行定义的话（注意`def`定义的都是==方法==），那么可以直接写为：

```scala
def mulOneAtATime(x: Int)(y: Int) = x * y
```

很多时候柯里化用于将单个函数参数提取出来，方便编译器进行类型推断，比如 Scala 中的`corresponds`方法：

```scala
def corresponds[B](that: Seq[B])(p: (A, B) => Boolean): Boolean
```

`that`和`p`是分开的两个参数，类型推断器可以推断出`B`出自`that`的类型，因此可以进一步分析作为参数`p`传入的函数：

```scala
val a = Array("Hello","World")
val b = Array("Hello","world")
a.corresponds(b)(_.equalsIgnoreCase(_))
```

## 控制抽象

Scala 中的控制抽象指的是程序员可以构建看上去像是编程语言关键字的函数：

```scala
def until(condition: => Boolean)(block: => Unit): Unit = {
  if (!condition) {
    block
    until(condition)(block)
  }
}

var x = 10
until(x == 0) {
  x -= 1
  println(x)
}
```

注意`until`的两个函数参数中，箭头左边都没写参数类型，这是因为这两个函数不接受参数，所以可以把`()`省略，然后在进行调用的时候使用==换名==调用参数。

所以换名调用，就是函数在被调用的时候，参数表达式不会被求值，比如在上面调用`until`的时候`x == 0`其实并没有被求值然后得到`false`，而是作为表达式运用在`until`的函数体中。

## return 表达式

通常是不需要写`return`的，但是在匿名函数中可以用`return`把返回值传递给它外层的具名函数：

```scala
def indexOf(str: String, ch: Char): Int = {
  var i = 0
  until(i == str.length) {
    if (str(i) == ch) {
      return i  // 直接就成为了 indexOf 的返回值
    }
    i += 1
  }
  return -1
}
```

注意，如果使用`return`，那么定义方法的时候就要指明返回值的类型。





