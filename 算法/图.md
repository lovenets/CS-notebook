# 无向图

## 一、数据结构

### 1.思想

为了表示方便，使用数组来保存顶点，顶点的名字就是它在数组中的索引。边则用它的两个顶点来表示。在实际开发中有三种实现方法可以考虑：

- 邻接矩阵：当顶点`v`和顶点`w`之间有相连接的边时，定义`v`行`w`列的元素为`true`。这种方法最大的缺陷就在于当顶点数很多时就需要很大的存储空间，这显然是不现实的。
- 边的数组：设计一个`Edge`类，含有两个`int`变量。这种方法虽然简单，但不利于实现一些算法。
- 邻接表数组：使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。这是较为优异的一种方法。

![邻接表数组](img\邻接表数组.jpg)

### 2.实现 

```java
/**
 * 无向图
 */
public class Graph {
    private int V;    // 顶点数目
    private int E;    // 边的数目
    private Bag<Integer>[] adj;  //邻接表

    public Graph(int v) {
        intiGraph(v);
    }

    public Graph(File file) {
        ByteBuffer bBuffer = ByteBuffer.allocateDirect(186140); //分配新的直接字节缓冲区
        StringBuffer sBuffer = new StringBuffer(186140);
        if (file == null) {
            return;
        }

        try (FileInputStream in = new FileInputStream(file); FileChannel channel = in.getChannel()) {
            CharBuffer charBuffer = null;
            Charset charset = Charset.forName("UTF-8");
            while (channel.read(bBuffer) != -1) {
                bBuffer.flip();
                charBuffer = charset.decode(bBuffer);
                sBuffer.append(charBuffer.toString());
                bBuffer.clear();
            }
            String content = sBuffer.toString();
            String[] contents = content.split("\\r\\n");
            int V = Integer.parseInt(contents[0]); // 顶点数
            intiGraph(V);
            String[] vertex;
            for (int i = 1; i < contents.length; i++) { // 每条边的两个顶点
                vertex = contents[i].split("\\s+");
                int v = Integer.parseInt(vertex[0]);
                int w = Integer.parseInt(vertex[1]);
                addEdge(v, w);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void intiGraph(int v) {
        this.V = v;
        this.E = 0;
        adj = new Bag[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new Bag<>();
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    // 添加一条边
    public void addEdge(int v, int w) {
        adj[v].add(w);   // 将 w 添加到 v 的链表中
        adj[w].add(v);   // 将 v 添加到 w 的链表中
        E++;
    }

    // 查找某个顶点的所有邻接顶点
    public Iterable<Integer> adj(int v) {
        return adj[v];
    }

    // 计算顶点的度数
    public int degree(int v) {
        int degree = 0;
        for (int i : adj(v)) {
            degree++;
        }
        return degree;
    }

    @Override
    public String toString() {
        String str = V + " vertices," + E + " edges\n";
        for (int v = 0; v < V; v++) {
            str += v + ": ";
            for (int w : this.adj(v)) {
                str += w + " ";
            }
            str += "\n";
        }
        return str;
    }
}
```

### 3.性能

- 使用的空间和$V+E$成正比
- 添加一条边需要的时间为常数
- 遍历顶点的所有邻接顶点所需的时间和该顶点的度数成正比（处理每个邻接顶点所需的时间为常数）

## 二、算法

### 1.深度优先搜索

搜索的本质就是遍历（连通图）每一个顶点。

#### （1）思想

在访问一个顶点时：

- 将其标记为已经访问
- 递归地访问它的所有还未被访问过的邻接顶点

#### （2）性能

标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。

#### （3）实现

```java
/**
 * 深度优先
 */
public class DepthFirstSearch {
    private boolean[] marked;
    private int count; // 记录 dfs 方法被调用了多少次，实际上就是某个连通子图的顶点数
    
    public DepthFirstSearch(Graph g, int source){
        marked = new boolean[g.V()];
        dfs(g,source);
    }
    
    private void dfs(Graph g,int v){
        marked[v] = true;  // 标记为已经访问过
        count++;
        for(int w : g.adj(v)){ // 访问当前顶点的所有邻接顶点
            if(!marked[w]){
                dfs(g,w); // 递归地访问还没有被访问过的顶点
            }
        }
    }
    
    public boolean isMarked(int v){
        return marked[v];
    }
    
    public int count(){
        return count;
    }
}
```

### 2.寻找路径

![寻找路径](img\寻找路径.jpg)

在深度优先算法的基础上稍加改进就可以得到寻找从起点到某个顶点的路径的算法。

注意在下面的实现中，`edgeTo`这个数组的意义，比如说从0到5的路径是`1->2->4->5`，那么`edgeTo[5]`的值就是4。

```java
/**
 * 深度优先
 */
public class DepthFirstSearch {
    private boolean[] marked;
    private int count; // 连通图的顶点数
    private int[] edgeTo;   // 从起点到某个顶点的路径上的最后一个已知顶点
    private final int source; // 起点

    public DepthFirstSearch(Graph g, int source){
        marked = new boolean[g.V()];
        edgeTo = new int[g.V()];
        this.source = source;
        dfs(g,source);
    }

    private void dfs(Graph g,int v){
        marked[v] = true;  // 标记为已经访问过
        //System.out.print(v + " ");
        count++;
        for(int w : g.adj(v)){ // 访问当前顶点的所有邻接顶点
            if(!marked[w]){
                edgeTo[w] = v; // 对于一个没有访问过的顶点而言，当前顶点就是路径上的最后一个已知顶点
                dfs(g,w); // 递归地访问还没有被访问过的顶点
            }
        }
    }

    public int count(){
        return count;
    }

    // 检查到某个顶点是否连通
    public boolean hashPathTo(int v){
        // 如果没有被标记过就是不连通
        return marked[v];
    }

    public Iterable<Integer> pathTo(int v){
        if(!hashPathTo(v)) {
            return null;
        }
        Stack<Integer> path = new Stack<>();
        for (int i = v; i != source ; i = edgeTo[i]) {
            path.push(i);
        }
        path.push(source);
        return path;
    }
}
```

基于深度优先算法的寻找路径算法所需的时间与路径长度成正比。

### 3.广度优先搜索

#### （1）思想

先将起点加入队列，然后重复以下步骤直到队列为空：

- 取队列的下一个顶点`v`并标记它
- 将与`v`相邻的所有未被标记过的顶点加入队列

#### （2）性能

- 对于从`s`可到的任意顶点`v`，广度优先算法都能找到一条==最短路径==。
- 所需的时间在最坏情况下与$V+E$成正比

#### （3）实现

```java
    private boolean[] marked;
    private int[] edgeTo;  // 从起点到某个顶点的路径上已知的最后一个顶点
    private final int source;

    public BreadthFirstSearch(Graph g,int source){
        this.source = source;
        marked = new boolean[g.V()];
        edgeTo = new int[g.V()];
        bfs(g,source);
    }

    // 广度优先搜索
    private void bfs(Graph g,int source){
        Queue<Integer> queue = new PriorityQueue<>();
        marked[source] = true;  // 标记起点
        queue.add(source);    // 首先把起点加入队列
        int v;
        while(!queue.isEmpty()){
            v = queue.remove(); // 取出队头
            for(int w : g.adj(v)){
                if(!marked[w]){ // 将每个未被标记的邻接顶点加入队列
                    edgeTo[w] = v;
                    marked[w] = true; // 标记
                    queue.add(w);
                }
            }
        }
    }

    public boolean hasPathTo(int v){
        return marked[v];
    }

    public Iterable<Integer> pathTo(int v){
        if(!hasPathTo(v)) {
            return null;
        }
        Stack<Integer> path = new Stack<>();
        for (int i = v; i != source ; i = edgeTo[i]) {
            path.push(i);
        }
        path.push(source);
        return path;
    }
}
```

深度优先和广度优先的不同之处实际上仅在于从数据结构中获取下一个顶点的规则：

- 广度优先获取最早加入的顶点
- 深度优先获取最晚加入的顶点

### 4.连通分量

图中连通的顶点构成连通分量，一幅图中可以有多个连通分量。

![3个连通分量](img\连通分量.jpg)

使用深度优先算法可以方便地找出所有的连通分量。

```java
public class ConnectedComponents {
    private boolean[] marked;
    private int[] id;   // id[v] 表示顶点 v 所在的连通分量标识
    private int count;  // 连通分量的总数

    public ConnectedComponents(Graph g) {
        marked = new boolean[g.V()];
        id = new int[g.V()];
        // 每一轮循环就是在获取一个连通分量
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i);
                count++;
            }
        }
    }

    // 深度优先搜索
    private void dfs(Graph g, int v) {
        marked[v] = true;
        id[v] = count;
        for (int w : g.adj(v)) {
            if (!marked[w]) {
                dfs(g, w);
            }
        }
    }

    // 检查两个顶点是否连通，就看它们是否在同一个连通分量
    public boolean connected(int v, int w) {
        return id[v] == id[w];
    }

    // 获取顶点 v 所在的连通分量
    public int id(int v) {
        return id[v];
    }

    // 连通分量个数
    public int count() {
        return count;
    }
}
```

## 三、符号图

在实际应用中，顶点名一般都是字符串，这种图叫做符号图。符号图的数据结构中主要有：

- 一个符号表`st`，保存了顶点名和索引的对应关系
- 一个数组`keys`，用作反向索引，保存每个顶点索引所对应的顶点名
- 一个图对象`g`，图中的顶点用的是顶点名的索引

![符号表的数据结构](img\符号表的数据结构.jpg)

```java
public class SymbolGraph {
    private Map<String,Integer> st;
    private String[] keys;
    private Graph g;

    public SymbolGraph(String fileName) {
        File file = new File(fileName);
        if(file == null){
            return;
        }
        ByteBuffer bBuffer = ByteBuffer.allocateDirect(186140); //分配新的直接字节缓冲区
        StringBuffer sBuffer = new StringBuffer(186140);

        try (FileInputStream in = new FileInputStream(file); FileChannel channel = in.getChannel()) {
            CharBuffer charBuffer = null;
            Charset charset = Charset.forName("UTF-8");
            while (channel.read(bBuffer) != -1) {
                bBuffer.flip();
                charBuffer = charset.decode(bBuffer);
                sBuffer.append(charBuffer.toString());
                bBuffer.clear();
            }
            String content = sBuffer.toString();
            String[] contents = content.split("\\r\\n");
            String[] vertices;
            // 构建索引
            st = new HashMap<>();
            for(String s1 : contents){
                vertices = s1.split("\\s+");
                for(String s2 : vertices){
                    if(!st.containsKey(s2)){
                        st.put(s2, st.size());
                    }
                }
            }
            // 构建反向索引
            keys = new String[st.size()];
            for(String name : st.keySet()){
                keys[st.get(name)] = name;
            }
            // 构造图
            g = new Graph(st.size());
            int v;
            int w;
            for(String s : contents){
                vertices = s.split("\\s+");
                v = st.get(vertices[0]);
                w = st.get(vertices[1]);
                g.addEdge(v, w);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 是否包含某个顶点
    public boolean contains(String name){
        return st.containsKey(name);
    }

    // 获取顶点名的索引
    public int index(String name){
        return st.get(name);
    }

    // 由索引获取顶点名
    public String name(int index){
        return keys[index];
    }

    public Graph G(){
        return g;
    }
}
```

## 习题

### 1.如何检测一个图是否存在平行边？

```java
    public boolean hasParallelEdge(Graph g, int source) {
        boolean[] neigh;
        boolean[] marked = new boolean[g.V()];
        Queue<Integer> queue = new PriorityQueue<>();
        queue.add(source);
        marked[source] = true;
        int v;
        while (!queue.isEmpty()) {
            v = queue.remove();
            neigh = new boolean[g.V()];
            // 如果当前顶点与顶点 w 邻接，那么 neigh[w] == true
            for (int w : g.adj(v)) {
                if (neigh[w]) {  // 说明 w 在当前顶点的邻接顶点列表中出现了两次
                    return true;
                } else {
                    neigh[w] = true;
                }
                // 进行广度优先遍历
                if (!marked[w]) {
                    marked[w] = true;
                    queue.add(w);
                }
            }
        }
        return false;
    }
```

### 2.在一幅连通图中，如果一条边被删除之后就会变为两个独立的连通分量，那么这条边称为桥。没有桥的图称为边连通图。设计一种基于深度优先搜索算法的数据结构，判断一个图是否为边连通图。

````java
public class Bridge {
    private int bridges;      // number of bridges
    private int cnt;          // counter
    private int[] pre;        // pre[v] = order in which dfs examines v
    private int[] low;        // low[v] = lowest preorder of any vertex connected to v

    public Bridge(Graph G) {
        low = new int[G.V()];
        pre = new int[G.V()];
        for (int v = 0; v < G.V(); v++)
            low[v] = -1;
        for (int v = 0; v < G.V(); v++)
            pre[v] = -1;

        for (int v = 0; v < G.V(); v++)
            if (pre[v] == -1)
                dfs(G, v, v);
    }

    public int components() { return bridges + 1; }

    private void dfs(Graph G, int u, int v) {
        pre[v] = cnt++;
        low[v] = pre[v];
        for (int w : G.adj(v)) {
            if (pre[w] == -1) {
                dfs(G, v, w);
                low[v] = Math.min(low[v], low[w]);
                if (low[w] == pre[w]) {
                    System.out.println(v + "-" + w + " is a bridge");
                    bridges++;
                }
            }

            // update low number - ignore reverse of edge leading to v
            else if (w != u)
                low[v] = Math.min(low[v], pre[w]);
        }
    }
}
````

# 有向图

## 一、数据结构

```java
/**
 * 有向图
 */
public class Digraph {
    private int V; // 顶点数
    private int E; // 边数
    private Bag<Integer>[] adj; // 邻接列表

    public Digraph(int v) {
        init(v);
    }

    private void init(int v) {
        V = v;
        E = 0;
        adj = new Bag[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new Bag<>();
        }
    }

    public Digraph(File file){
        ByteBuffer bBuffer = ByteBuffer.allocateDirect(186140); //分配新的直接字节缓冲区
        StringBuffer sBuffer = new StringBuffer(186140);
        if (file == null) {
            return;
        }

        try (FileInputStream in = new FileInputStream(file); FileChannel channel = in.getChannel()) {
            CharBuffer charBuffer = null;
            Charset charset = Charset.forName("UTF-8");
            while (channel.read(bBuffer) != -1) {
                bBuffer.flip();
                charBuffer = charset.decode(bBuffer);
                sBuffer.append(charBuffer.toString());
                bBuffer.clear();
            }
            String content = sBuffer.toString();
            String[] contents = content.split("\\r\\n");
            int V = Integer.parseInt(contents[0]); // 顶点数
            init(V);
            String[] vertex;
            for (int i = 1; i < contents.length; i++) { // 每条边的两个顶点
                vertex = contents[i].split("\\s+");
                int v = Integer.parseInt(vertex[0]);
                int w = Integer.parseInt(vertex[1]);
                addEdge(v, w);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public int V() {
        return this.V;
    }

    public int E() {
        return this.E;
    }

    // 添加一条有向边
    public void addEdge(int src, int dst) {
        adj[src].add(dst);
        E++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }

    // 生成反向图
    public Digraph reverse() {
        Digraph R = new Digraph(V);
        for (int i = 0; i < V; i++) {
            for (int w : adj(i)) {
                R.addEdge(w, i);
            }
        }
        return R;
    }

    @Override
    public String toString() {
        String str;
        str = V + " vertices," + E + " edges\n";
        for (int i = 0; i < V; i++) {
            str += i + ": ";
            for(int w : adj[i]){
                str += w + " ";
            }
            str += "\n";
        }
        return str;
    }
}
```

## 二、 算法

### 1.可达性

可以从顶点`s`沿着有向边到达顶点`d`，那么对于偶`s`而言`d`是可达的。深度优先搜索算法是一种适合处理有向图的算法，因此可达性分析就相当于从起点出发尝试遍历图中其他顶点。

```java
/**
 * 基于深度优先的有向图可达性
 */
public class DirectedDFS {
    private boolean[] marked;

    // 在图中找到从 s 可以达到的所有顶点
    public DirectedDFS(Digraph g,int src){
        marked = new boolean[g.V()];
        dfs(g,src);
    }

    // 在图中找到从 sources 中的所有顶点可以到达的所有顶点
    public DirectedDFS(Digraph g,Iterable<Integer> sources){
        marked = new boolean[g.V()];
        for(int s : sources){
            if(!marked[s]) {
                dfs(g,s);
            }
        }
    }

    // 深度优先搜索
    private void dfs(Digraph g,int v){
        marked[v] = true;
        for(int w : g.adj(v)){
            if(!marked[w]){
                dfs(g,w);
            }
        }
    }

    // 某个顶点是否可达
    public boolean reachable(int v){
        return marked[v];
    }
}
```

> 可达性分析的一个重要应用就是 JVM 的 GC 机制，一个对象就是一个顶点，一个对象对另一个对象的引用表示为边，不可达对象会被回收。

### 2.环的检测

基于深度优先搜索，如果找到了一条边`v->w`且`w`在递归调用的栈中，那么就说明找到了一个环。在实际应用中，环的数量可能是图的大小的指数级别，所以只需找出一个环无需找出所有环。

```java
/**
 * 基于深度优先搜索的有向环检测
 */
public class DirectedCycle {
    private boolean[] marked;
    private int[] edgeTo;
    private Stack<Integer> cycle; // 有向环中的所有顶点
    private boolean[] onStack;    // 递归调用期间栈中的顶点

    public DirectedCycle(Digraph g) {
        edgeTo = new int[g.V()];
        marked = new boolean[g.V()];
        onStack = new boolean[g.V()];
        for (int i = 0; i < g.V(); i++) {
            if (!marked[i]) {
                dfs(g, i);
            }
        }
    }

    private void dfs(Digraph g, int v) {
        onStack[v] = true; // 标记当前结点，意味着压入栈中
        marked[v] = true;
        for (int w : g.adj(v)) {
            if (hasCycle()) { // 只需检测一个环
                return;
            } else if (!marked[w]) {
                edgeTo[w] = v;
                dfs(g, w);
            } else if (onStack[w]) { // w 还在栈中，意味着对 w 的邻接顶点的递归调用还未结束，而此时又遍历到了 w，说明存在环
                cycle = new Stack<>();
                // 记录环的结点
                for (int i = v; i != w; i = edgeTo[i]) {
                    cycle.push(i);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }
        onStack[v] = false;
    }

    public boolean hasCycle() {
        return cycle != null;
    }

    // 返回环的顶点
    public Iterable<Integer> cycle() {
        return cycle;
    }
}
```

> 在实际应用中，有些情况下需要的是有向无环图，比如有优先级限制的任务调度问题，这种问题中不允许环的存在。

### 3.拓扑排序

优先级限制的调度问题实际上就是有向图的拓扑排序问题。将有向图中的所有顶点进行排序，使所有的有向边均从排在前面（优先级大）的元素指向排在后面（优先级小）的元素。只有无环图才能实现拓扑排序。

![拓扑排序](img\拓扑排序.jpg)

一幅有向无环图的拓扑排序就是顶点的逆后序排序。

```java
/**
 * 有向无环图的拓扑排序
 */
public class Topological {
    private Iterable<Integer> order; // 顶点的拓扑序列

    public Topological(Digraph g){
        DirectedCycle directedCycle = new DirectedCycle(g);
        if(!directedCycle.hasCycle()){ // 有向无环图才能拓扑排序
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(g);
            order = depthFirstOrder.reversePost();
        }
    }

    public Iterable<Integer> order(){
        return order;
    }

    // 是否为有向无环图
    public boolean isDAG(){
        return order != null;
    }
}

/**
 * 深度优先搜索对顶点进行排序
 */
public class DepthFirstOrder {
    private boolean[] marked;
    private Queue<Integer> pre; // 所有顶点前序排列
    private Queue<Integer> post; // 所有顶点后序排列
    private Stack<Integer> reversePost; // 所有顶点逆后序排列

    public DepthFirstOrder(Digraph g){
        pre = new LinkedList<>();
        post = new LinkedList<>();
        reversePost = new Stack<>();
        marked = new boolean[g.V()];

        for (int i = 0; i < g.V(); i++) {
            if(!marked[i]){
                dfs(g,i);
            }
        }
    }

    private void dfs(Digraph g,int v){
        pre.add(v);
        marked[v] = true;
        for(int w : g.adj(v)){
            if(!marked[w]){
                dfs(g,w);
            }
        }
        post.add(v);
        reversePost.push(v);
    }

    public Iterable<Integer> pre(){
        return pre;
    }

    public Iterable<Integer> post(){
        return post;
    }

    public Iterable<Integer> reversePost(){
        return reversePost;
    }
}
```

### 3.强连通性

在有向图中，如果两个顶点是互相可达的，那么称它们为强连通的。如果有向图中任意两个顶点都是强连通的，那么这幅图也是强连通的。

计算强连通分量的高效算法是 Kosaraju 算法：

- 计算有向图的反向图的逆后序排序
- 在有向图中进行深度优先搜索，但是要按照上一步得到的顺序访问未被标记的顶点
- 所有在同一个递归调用中被访问到的顶点都处在一个连通分量中

![Kosaraju 算法](img\Kosaraju 算法.jpg)

```java
/**
 * 计算强连通分量
 */
public class KosarajuSCC {
    private boolean[] marked;
    private int[] id;  // 强连通分量的标识
    private int count; // 强连通分量的数量

    public KosarajuSCC(Digraph g) {
        marked = new boolean[g.V()];
        id = new int[g.V()];
        DepthFirstOrder order = new DepthFirstOrder(g);
        // 按照反向图的逆后序访问未被访问过的顶点
        // 每一轮循环找到一个强连通分量
        for(int s : order.reversePost()){
            if(!marked[s]){
                dfs(g,s);
                count++;
            }
        }
    }

    private void dfs(Digraph g,int v){
        marked[v] = true;
        id[v] = count;
        for(int w : g.adj(v)){
            if(!marked[w]){
                dfs(g,w);
            }
        }
    }

    // 判断两个顶点是否强连通
    public boolean stronglyConnected(int v,int w){
        return id[v] == id[w];
    }

    public int id(int v){
        return id[v];
    }

    public int count(){
        return count;
    }
}
```

在`dfs`中如果用广度优先算法也是可以解决问题的。

### 4.顶点对可达性

对于无向图，顶点对的可达性就等价于连通性；对于有向图，`w`是从`v`可达的意味着存在一条`v->w`的路径，这和强连通性很不同。数学上通过计算有向图的传递闭包来发现顶点对的可达性。传递闭包是由相同的一组顶点组成的另一幅有向图，当且仅当在有向图中`w`是从`v`可达的，在传递闭包中存在一条从`v`指向`w`的边。

```java
/**
 * 有向图可达性
 * 基于传递闭包
 */
public class TransitiveClosure {
    private DirectedDFS[] all; // all[v] 存储了以 v 起点的可达性信息
    
    public TransitiveClosure(Digraph g) {
        all = new DirectedDFS[g.V()];
        for (int i = 0; i < g.V(); i++) {
            all[i] = new DirectedDFS(g, i);
        }
    }
    
    public boolean reachable(int v,int w){
        return all[v].reachable(w);
    }
}
```

注意：这个算法所需的空间是平方级别的，因此不适用于大型有向图（比如网络）。

## 习题

### 1.用队列实现一个非递归的拓扑排序方法。

算法：遍历所有边，队列初始化时包含所有入度为0顶点。然后，重复以下操作直到队列为空：

- 从队列中删除一个顶点并将其标记
- 遍历由被删除顶点指出的所有边，将所有被指向的顶点的入度减1
- 如果顶点的入度变为0，将它插入队列

```java
/**
 * 基于队列的有向无环图拓扑排序
 */
public class QueueTopological {
    private Queue<Integer> order;
    private int[] ranks;   // rank[v] 就是顶点 v 拓扑序列中的位置

    public QueueTopological(Digraph g) {
        int[] indegree = new int[g.V()];
        // 初始化所有顶点的入度
        for (int i = 0; i < g.V(); i++) {
            indegree[i] = g.indegree(i);
        }

        ranks = new int[g.V()];
        order = new PriorityQueue<>();
        int count = 0;  // 顶点在排序中的序号

        // 初始化队列包含所有入度为0的顶点
        Queue<Integer> queue = new PriorityQueue<>();
        for (int i = 0; i < g.V(); i++) {
            if(indegree[i] == 0){
                queue.add(i);
            }
        }
        
        while(!queue.isEmpty()){
            int v = queue.remove();
            order.add(v);
            ranks[v] = count++;
            for(int w : g.adj(v)){
                indegree[w]--;
                if(indegree[w] == 0){
                    queue.add(w);
                }
            }
        }
        
        // 入度大于1的顶点构成的子图中含有环
        if(count != g.V()){
            order = null;
        }
    }
}
```

### 2.给定一个有向图，找出图中最短的有向环（即边数最少）。

算法：通过顶点`s`的最短环就是边`v->s`加上`s`到`v`的最短路径。

```java
public class ShortestDirectedCycle {
    private Stack<Integer> cycle;  // 环
    private int length;       // 最短环的长度

    public ShortestDirectedCycle(Digraph g) {
        Digraph r = g.reverse();
        length = g.V() + 1; // 极端情况下整幅图就是一个环，所以环的最大长度就是顶点数加1
        // 以每个顶点为起点，依次进行广度优先搜索
        for (int v = 0; v < g.V(); v++) {
            BreadthFirstDirectedPath bfs = new BreadthFirstDirectedPath(r, v); // 这里用的是反向图，
                                                                               // 是为了保证栈中顶点的顺序正确
            for (int w : g.adj(v)) {
                if (bfs.hasPathTo(w) && (bfs.distTo(w) + 1) < length) {
                    length = bfs.distTo(w) + 1; // 更新环的长度
                    cycle = new Stack<>();
                    for (int x : bfs.pathTo(w)) {
                        cycle.push(x);
                    }
                }
            }
        }
    }

    public boolean hasCycle() {
        return cycle != null;
    }

    public Iterable<Integer> cycle() {
        return cycle;

    }

    public int length() {
        return length;
    }
}
```

# 最小生成树

图的生成树是它的一棵含有其所有顶点的无环连通子图（因此最小生成树只可能存在于连通图中），一幅加权无向图的最小生成树就是它的一棵权值最小的生成树。

## 一、原理

### 1.切分定理

图的切分是将图的所有顶点分为两个非空且不重复的两个集合，横切边是一条连接两个属于不同集合的顶点的边。

在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。

![切分定理](img\切分定理.jpg)

### 2.贪心算法

将最小生成树的边标记为黑色。初始状态下加权连通图的所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将权重最小的横切边标记为黑色。反复，直到标记了$V-1$条黑色边为止。

## 二、 数据结构

设计一个`Edge`结构来表示加权边，图的邻接链表存储的就是与该顶点连接的边，因此同一条边会被存储两次。

![加权无向图](img\加权无向图.jpg)

```java
/**
 * 加权边
 */
public class Edge implements Comparable<Edge>{
    private final int v;  // 顶点之一
    private final int w;  // 另一个顶点
    private final double weight; // 权重

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double getWeight() {
        return weight;
    }

    // 获取顶点之一
    public int either(){
        return v;
    }

    // 获取另一个顶点
    public int other(int vertex){
        return vertex == v ? w : v;
    }

    @Override
    public int compareTo(Edge o) {
        if(this.weight < o.weight) {
            return -1;
        } else if(this.weight > o.weight){
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public String toString() {
        return String.format("%d-%d %.2f",v,w,weight);
    }
}
```

```java
/**
 * 加权无向图
 */
public class EdgeWeightedGraph {
    private int V; // 顶点总数
    private int E; // 边的总数
    private Bag<Edge>[] adj; // 邻接表

    public EdgeWeightedGraph(int v) {
        init(v);
    }

    public EdgeWeightedGraph(File file) {
        ByteBuffer bBuffer = ByteBuffer.allocateDirect(186140);
        StringBuffer sBuffer = new StringBuffer(186140);
        if (file == null) {
            return;
        }

        try (FileInputStream in = new FileInputStream(file); FileChannel channel = in.getChannel()) {
            CharBuffer charBuffer = null;
            Charset charset = Charset.forName("UTF-8");
            while (channel.read(bBuffer) != -1) {
                bBuffer.flip();
                charBuffer = charset.decode(bBuffer);
                sBuffer.append(charBuffer.toString());
                bBuffer.clear();
            }
            String content = sBuffer.toString();
            String[] contents = content.split("\\r\\n");
            int V = Integer.parseInt(contents[0]); // 顶点数
            init(V);
            String[] data;
            int v;
            int w;
            double weight;
            for (int i = 1; i < contents.length; i++) {
                data = contents[i].split("\\s+");
                v = Integer.parseInt(data[0]); // 顶点之一
                w = Integer.parseInt(data[1]); // 另一个顶点
                weight = Double.parseDouble(data[2]); // 权重
                addEdge(new Edge(v, w, weight));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int init(int v) {
        this.V = v;
        this.E = 0;
        adj = new Bag[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new Bag<>();
        }
        return V;
    }

    public int getV() {
        return V;
    }

    public int getE() {
        return E;
    }

    public void addEdge(Edge e) {
        int v = e.either();
        int w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    public Iterable<Edge> edges() {
        Bag<Edge> b = new Bag<>();
        for (int i = 0; i < V; i++) {
            for (Edge e : adj[i]) {
                if (e.other(i) > i) { // 保证添加到 b 中的边不重复
                    b.add(e);
                }
            }
        }
        return b;
    }

    @Override
    public String toString() {
        String str = "";
        str += V + " vertices," + E + " edges\n";
        for (int i = 0; i < V; i++) {
            str += i + ": ";
            for (Edge e : adj[i]) {
                str += "(" + e.either() + "," + e.other(e.either()) + "," + e.getWeight() + ") ";
            }
            str += "\n";
        }
        return str;
    }
}
```

## 三、Prim 算法

Prim 算法能够得到任意加权无向图的最小生成树。

### 1.思想

一开始最小生成树只有一个顶点，算法的每一步都会为这棵树添加一条边，要求这条边连接树中的顶点和不在树中的顶点且权重最小。

### 2.实现

```java
/**
 * Prim 算法
 */
public class PrimMST {
    private Edge[] edgeTo;    // edgeTo[v] 是连接顶点 v 和树的最短的边
    private double[] distTo;  // distTo[v] 是 edgeTo[v] 对应的边的权重
    private boolean[] marked; // marked[v] == true 意味着顶点 v 已经在树中
    private IndexMinPQ<Double> pq;  // 有效横切边的权重

    public PrimMST(EdgeWeightedGraph graph) {
        edgeTo = new Edge[graph.getV()];
        distTo = new double[graph.getV()];
        marked = new boolean[graph.getV()];
        for (int i = 0; i < graph.getV(); i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        pq = new IndexMinPQ<>(graph.getV());

        // 初始化时将顶点0放入树中，并用权重0.0初始化队列
        distTo[0] = 0.0;
        pq.insert(0, 0.0);
        while (!pq.isEmpty()) {
            visit(graph, pq.delMin()); // 将权重最小的横切边变为树的边
        }
    }

    private void visit(EdgeWeightedGraph g, int v) {
        marked[v] = true;
        // 更新有效最短横切边
        for (Edge e : g.adj(v)) {
            int w = e.other(v);

            if (marked[w]) { // 边 v-w 已经在树中，这条横切边失效
                continue;
            }
            if (e.getWeight() < distTo[w]) { // 找到一条连接 w 和树的更近的边
                edgeTo[w] = e;
                distTo[w] = e.getWeight();
                // 更新队列
                if (pq.contains(w)) {
                    pq.change(w, distTo[w]);
                } else {
                    pq.insert(w, distTo[w]);
                }
            }
        }
    }

    // 最小生成树的所有边
    public Iterable<Edge> edges() {
        Edge[] e = Arrays.copyOfRange(edgeTo, 1, edgeTo.length - 1);
        return Arrays.asList(e);
    }

    // 最小生成树的权重
    public double weight() {
        double weight = 0.0;
        for (double w : distTo) {
            weight += w;
        }
        return weight;
    }

}

class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {
    private int maxN;        // maximum number of elements on PQ
    private int n;           // number of elements on PQ
    private int[] pq;        // binary heap using 1-based indexing
    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i
    private Key[] keys;      // keys[i] = priority of i

    /**
     * Initializes an empty indexed priority queue with indices between {@code 0}
     * and {@code maxN - 1}.
     * @param  maxN the keys on this priority queue are index from {@code 0}
     *         {@code maxN - 1}
     * @throws IllegalArgumentException if {@code maxN < 0}
     */
    public IndexMinPQ(int maxN) {
        if (maxN < 0) throw new IllegalArgumentException();
        this.maxN = maxN;
        n = 0;
        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??
        pq   = new int[maxN + 1];
        qp   = new int[maxN + 1];                   // make this of length maxN??
        for (int i = 0; i <= maxN; i++)
            qp[i] = -1;
    }

    /**
     * Returns true if this priority queue is empty.
     *
     * @return {@code true} if this priority queue is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return n == 0;
    }

    /**
     * Is {@code i} an index on this priority queue?
     *
     * @param  i an index
     * @return {@code true} if {@code i} is an index on this priority queue;
     *         {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     */
    public boolean contains(int i) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        return qp[i] != -1;
    }

    /**
     * Returns the number of keys on this priority queue.
     *
     * @return the number of keys on this priority queue
     */
    public int size() {
        return n;
    }

    /**
     * Associates key with index {@code i}.
     *
     * @param  i an index
     * @param  key the key to associate with index {@code i}
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws IllegalArgumentException if there already is an item associated
     *         with index {@code i}
     */
    public void insert(int i, Key key) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue");
        n++;
        qp[i] = n;
        pq[n] = i;
        keys[i] = key;
        swim(n);
    }

    /**
     * Returns an index associated with a minimum key.
     *
     * @return an index associated with a minimum key
     * @throws NoSuchElementException if this priority queue is empty
     */
    public int minIndex() {
        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
        return pq[1];
    }

    /**
     * Returns a minimum key.
     *
     * @return a minimum key
     * @throws NoSuchElementException if this priority queue is empty
     */
    public Key minKey() {
        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
        return keys[pq[1]];
    }

    /**
     * Removes a minimum key and returns its associated index.
     * @return an index associated with a minimum key
     * @throws NoSuchElementException if this priority queue is empty
     */
    public int delMin() {
        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
        int min = pq[1];
        exch(1, n--);
        sink(1);
        assert min == pq[n+1];
        qp[min] = -1;        // delete
        keys[min] = null;    // to help with garbage collection
        pq[n+1] = -1;        // not needed
        return min;
    }

    /**
     * Returns the key associated with index {@code i}.
     *
     * @param  i the index of the key to return
     * @return the key associated with index {@code i}
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws NoSuchElementException no key is associated with index {@code i}
     */
    public Key keyOf(int i) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        else return keys[i];
    }

    /**
     * Change the key associated with index {@code i} to the specified value.
     *
     * @param  i the index of the key to change
     * @param  key change the key associated with index {@code i} to this key
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws NoSuchElementException no key is associated with index {@code i}
     */
    public void changeKey(int i, Key key) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        keys[i] = key;
        swim(qp[i]);
        sink(qp[i]);
    }

    /**
     * Change the key associated with index {@code i} to the specified value.
     *
     * @param  i the index of the key to change
     * @param  key change the key associated with index {@code i} to this key
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @deprecated Replaced by {@code changeKey(int, Key)}.
     */
    @Deprecated
    public void change(int i, Key key) {
        changeKey(i, key);
    }

    /**
     * Decrease the key associated with index {@code i} to the specified value.
     *
     * @param  i the index of the key to decrease
     * @param  key decrease the key associated with index {@code i} to this key
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws IllegalArgumentException if {@code key >= keyOf(i)}
     * @throws NoSuchElementException no key is associated with index {@code i}
     */
    public void decreaseKey(int i, Key key) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        if (keys[i].compareTo(key) <= 0)
            throw new IllegalArgumentException("Calling decreaseKey() with given argument would not strictly decrease the key");
        keys[i] = key;
        swim(qp[i]);
    }

    /**
     * Increase the key associated with index {@code i} to the specified value.
     *
     * @param  i the index of the key to increase
     * @param  key increase the key associated with index {@code i} to this key
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws IllegalArgumentException if {@code key <= keyOf(i)}
     * @throws NoSuchElementException no key is associated with index {@code i}
     */
    public void increaseKey(int i, Key key) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        if (keys[i].compareTo(key) >= 0)
            throw new IllegalArgumentException("Calling increaseKey() with given argument would not strictly increase the key");
        keys[i] = key;
        sink(qp[i]);
    }

    /**
     * Remove the key associated with index {@code i}.
     *
     * @param  i the index of the key to remove
     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
     * @throws NoSuchElementException no key is associated with index {@code i}
     */
    public void delete(int i) {
        if (i < 0 || i >= maxN) throw new IllegalArgumentException();
        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
        int index = qp[i];
        exch(index, n--);
        swim(index);
        sink(index);
        keys[i] = null;
        qp[i] = -1;
    }


    /***************************************************************************
     * General helper functions.
     ***************************************************************************/
    private boolean greater(int i, int j) {
        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;
    }

    private void exch(int i, int j) {
        int swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
        qp[pq[i]] = i;
        qp[pq[j]] = j;
    }


    /***************************************************************************
     * Heap helper functions.
     ***************************************************************************/
    private void swim(int k) {
        while (k > 1 && greater(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && greater(j, j+1)) j++;
            if (!greater(k, j)) break;
            exch(k, j);
            k = j;
        }
    }


    /***************************************************************************
     * Iterators.
     ***************************************************************************/

    /**
     * Returns an iterator that iterates over the keys on the
     * priority queue in ascending order.
     * The iterator doesn't implement {@code remove()} since it's optional.
     *
     * @return an iterator that iterates over the keys in ascending order
     */
    public Iterator<Integer> iterator() { return new HeapIterator(); }

    private class HeapIterator implements Iterator<Integer> {
        // create a new pq
        private IndexMinPQ<Key> copy;

        // add all elements to copy of heap
        // takes linear time since already in heap order so no keys move
        public HeapIterator() {
            copy = new IndexMinPQ<Key>(pq.length - 1);
            for (int i = 1; i <= n; i++)
                copy.insert(pq[i], keys[pq[i]]);
        }

        public boolean hasNext()  { return !copy.isEmpty();                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Integer next() {
            if (!hasNext()) throw new NoSuchElementException();
            return copy.delMin();
        }
    }
}
```

##  四、Kruskal 算法

这个算法也能生成任意加权无向图的最小生成树。

### 1.思想 

按照边的权重顺序（从小到大）处理，将边加入最小生成树中，要求加入的边不会与已经加入的边构成环，直到加入了$V-1$条边。

### 2.实现

```java
public class KruscalMST {
    private Queue<Edge> mst; // 最小生成树的边
    
    private double weight;   // 最小生成树的权重

    public KruscalMST(EdgeWeightedGraph g){
        mst = new Queue<>();
        MinPQ<Edge> pq = new MinPQ<>(g.getE());
        UF uf = new UF(g.getV());
        
        for(Edge e : g.edges()){
            pq.insert(e);
        }

        Edge e;
        int v;
        int w;
        while(!pq.isEmpty() && mst.size() < g.getV() - 1){
            e = pq.delMin(); // 取权重最小的边
            v = e.either();
            w = e.other(v);
            if(!uf.connected(v, w)){ // 不会构成环
                uf.union(v, w);
                mst.enqueue(e); // 将这条边加入生成树中
                weight += e.getWeight(); // 累加权重
            }
        }
    }

    public Iterable<Edge> edges(){
        return mst;
    }

    public double weight(){
        return weight;
    }
}

class Queue<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of queue
    private Node<Item> last;     // end of queue
    private int n;               // number of elements on queue

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty queue.
     */
    public Queue() {
        first = null;
        last  = null;
        n = 0;
    }

    /**
     * Returns true if this queue is empty.
     *
     * @return {@code true} if this queue is empty; {@code false} otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this queue.
     *
     * @return the number of items in this queue
     */
    public int size() {
        return n;
    }

    /**
     * Returns the item least recently added to this queue.
     *
     * @return the item least recently added to this queue
     * @throws NoSuchElementException if this queue is empty
     */
    public Item peek() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        return first.item;
    }

    /**
     * Adds the item to this queue.
     *
     * @param  item the item to add
     */
    public void enqueue(Item item) {
        Node<Item> oldlast = last;
        last = new Node<Item>();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else           oldlast.next = last;
        n++;
    }

    /**
     * Removes and returns the item on this queue that was least recently added.
     *
     * @return the item on this queue that was least recently added
     * @throws NoSuchElementException if this queue is empty
     */
    public Item dequeue() {
        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
        Item item = first.item;
        first = first.next;
        n--;
        if (isEmpty()) last = null;   // to avoid loitering
        return item;
    }

    /**
     * Returns a string representation of this queue.
     *
     * @return the sequence of items in FIFO order, separated by spaces
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Item item : this) {
            s.append(item);
            s.append(' ');
        }
        return s.toString();
    }

    /**
     * Returns an iterator that iterates over the items in this queue in FIFO order.
     *
     * @return an iterator that iterates over the items in this queue in FIFO order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

class MinPQ<Key> implements Iterable<Key> {
    private Key[] pq;                    // store items at indices 1 to n
    private int n;                       // number of items on priority queue
    private Comparator<Key> comparator;  // optional comparator

    /**
     * Initializes an empty priority queue with the given initial capacity.
     *
     * @param  initCapacity the initial capacity of this priority queue
     */
    public MinPQ(int initCapacity) {
        pq = (Key[]) new Object[initCapacity + 1];
        n = 0;
    }

    /**
     * Initializes an empty priority queue.
     */
    public MinPQ() {
        this(1);
    }

    /**
     * Initializes an empty priority queue with the given initial capacity,
     * using the given comparator.
     *
     * @param  initCapacity the initial capacity of this priority queue
     * @param  comparator the order in which to compare the keys
     */
    public MinPQ(int initCapacity, Comparator<Key> comparator) {
        this.comparator = comparator;
        pq = (Key[]) new Object[initCapacity + 1];
        n = 0;
    }

    /**
     * Initializes an empty priority queue using the given comparator.
     *
     * @param  comparator the order in which to compare the keys
     */
    public MinPQ(Comparator<Key> comparator) {
        this(1, comparator);
    }

    /**
     * Initializes a priority queue from the array of keys.
     * <p>
     * Takes time proportional to the number of keys, using sink-based heap construction.
     *
     * @param  keys the array of keys
     */
    public MinPQ(Key[] keys) {
        n = keys.length;
        pq = (Key[]) new Object[keys.length + 1];
        for (int i = 0; i < n; i++)
            pq[i+1] = keys[i];
        for (int k = n/2; k >= 1; k--)
            sink(k);
        assert isMinHeap();
    }

    /**
     * Returns true if this priority queue is empty.
     *
     * @return {@code true} if this priority queue is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return n == 0;
    }

    /**
     * Returns the number of keys on this priority queue.
     *
     * @return the number of keys on this priority queue
     */
    public int size() {
        return n;
    }

    /**
     * Returns a smallest key on this priority queue.
     *
     * @return a smallest key on this priority queue
     * @throws NoSuchElementException if this priority queue is empty
     */
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        return pq[1];
    }

    // helper function to double the size of the heap array
    private void resize(int capacity) {
        assert capacity > n;
        Key[] temp = (Key[]) new Object[capacity];
        for (int i = 1; i <= n; i++) {
            temp[i] = pq[i];
        }
        pq = temp;
    }

    /**
     * Adds a new key to this priority queue.
     *
     * @param  x the key to add to this priority queue
     */
    public void insert(Key x) {
        // double size of array if necessary
        if (n == pq.length - 1) resize(2 * pq.length);

        // add x, and percolate it up to maintain heap invariant
        pq[++n] = x;
        swim(n);
        assert isMinHeap();
    }

    /**
     * Removes and returns a smallest key on this priority queue.
     *
     * @return a smallest key on this priority queue
     * @throws NoSuchElementException if this priority queue is empty
     */
    public Key delMin() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        Key min = pq[1];
        exch(1, n--);
        sink(1);
        pq[n+1] = null;     // to avoid loiterig and help with garbage collection
        if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);
        assert isMinHeap();
        return min;
    }


    /***************************************************************************
     * Helper functions to restore the heap invariant.
     ***************************************************************************/

    private void swim(int k) {
        while (k > 1 && greater(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && greater(j, j+1)) j++;
            if (!greater(k, j)) break;
            exch(k, j);
            k = j;
        }
    }

    /***************************************************************************
     * Helper functions for compares and swaps.
     ***************************************************************************/
    private boolean greater(int i, int j) {
        if (comparator == null) {
            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) > 0;
        }
        else {
            return comparator.compare(pq[i], pq[j]) > 0;
        }
    }

    private void exch(int i, int j) {
        Key swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
    }

    // is pq[1..N] a min heap?
    private boolean isMinHeap() {
        return isMinHeap(1);
    }

    // is subtree of pq[1..n] rooted at k a min heap?
    private boolean isMinHeap(int k) {
        if (k > n) return true;
        int left = 2*k;
        int right = 2*k + 1;
        if (left  <= n && greater(k, left))  return false;
        if (right <= n && greater(k, right)) return false;
        return isMinHeap(left) && isMinHeap(right);
    }


    /**
     * Returns an iterator that iterates over the keys on this priority queue
     * in ascending order.
     * <p>
     * The iterator doesn't implement {@code remove()} since it's optional.
     *
     * @return an iterator that iterates over the keys in ascending order
     */
    public Iterator<Key> iterator() {
        return new HeapIterator();
    }

    private class HeapIterator implements Iterator<Key> {
        // create a new pq
        private MinPQ<Key> copy;

        // add all items to copy of heap
        // takes linear time since already in heap order so no keys move
        public HeapIterator() {
            if (comparator == null) copy = new MinPQ<Key>(size());
            else                    copy = new MinPQ<Key>(size(), comparator);
            for (int i = 1; i <= n; i++)
                copy.insert(pq[i]);
        }

        public boolean hasNext()  { return !copy.isEmpty();                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Key next() {
            if (!hasNext()) throw new NoSuchElementException();
            return copy.delMin();
        }
    }
}

class UF {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    /**
     * Initializes an empty union–find data structure with {@code n} sites
     * {@code 0} through {@code n-1}. Each site is initially in its own
     * component.
     *
     * @param  n the number of sites
     * @throws IllegalArgumentException if {@code n < 0}
     */
    public UF(int n) {
        if (n < 0) throw new IllegalArgumentException();
        count = n;
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    /**
     * Returns the component identifier for the component containing site {@code p}.
     *
     * @param  p the integer representing one site
     * @return the component identifier for the component containing site {@code p}
     * @throws IllegalArgumentException unless {@code 0 <= p < n}
     */
    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    /**
     * Returns the number of components.
     *
     * @return the number of components (between {@code 1} and {@code n})
     */
    public int count() {
        return count;
    }

    /**
     * Returns true if the the two sites are in the same component.
     *
     * @param  p the integer representing one site
     * @param  q the integer representing the other site
     * @return {@code true} if the two sites {@code p} and {@code q} are in the same component;
     *         {@code false} otherwise
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     */
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    /**
     * Merges the component containing site {@code p} with the
     * the component containing site {@code q}.
     *
     * @param  p the integer representing one site
     * @param  q the integer representing the other site
     * @throws IllegalArgumentException unless
     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
     */
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make root of smaller rank point to root of larger rank
        if      (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;
        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;
        else {
            parent[rootQ] = rootP;
            rank[rootP]++;
        }
        count--;
    }

    // validate that p is a valid index
    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));
        }
    }
}
```

## 习题

### 1.如何生成最大生成树？

把原图所有边的权重变为负数。

### 2.给定一幅图，并且已经得到最小生成树。从图中删除一条边，删除这条边后图仍然保持连通。如何在与$E$成正比的时间内生成新图的最小生成树？

（1）如果被删除的边不在原先的最小生成树中，那么最小生成树不变。

（2）如果被删除的边在原先的最小生成树中，删除这条边之后原先的最小生成树被分为两个连通分量，添加一条两个顶点分别位于两个分量并且权值最小的边，重新得到一棵最小生成树。

### 3.给定一幅图，并且已经得到最小生成树。添加一条边，如何在与$V$成正比的时间内得到新的最小生成树？

添加一条边后最小生成树就会变成环，所以删除环中权重最大的边。

### 4.实现  Boruvka 算法 

这个算法的思想是逐步添加边到一个生成树森林中。找到连接两棵树的权重最小的边，然后把这些边都加入最小生成树中。重复这个步骤，直到得到一棵完整的最小生成树。

![Boruvka](img\Boruvka.gif)

```java
public class BoruvkaMST {
    private static final double FLOATING_POINT_EPSILON = 1E-12;

    private Bag<Edge> mst = new Bag<Edge>();    // edges in MST
    private double weight;                      // weight of MST

    /**
     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
     * @param G the edge-weighted graph
     */
    public BoruvkaMST(EdgeWeightedGraph G) {
        UF uf = new UF(G.V());

        // repeat at most log V times or until we have V-1 edges
        for (int t = 1; t < G.V() && mst.size() < G.V() - 1; t = t + t) {

            // foreach tree in forest, find closest edge
            // if edge weights are equal, ties are broken in favor of first edge in G.edges()
            Edge[] closest = new Edge[G.V()];
            for (Edge e : G.edges()) {
                int v = e.either(), w = e.other(v);
                int i = uf.find(v), j = uf.find(w);
                if (i == j) continue;   // same tree
                if (closest[i] == null || less(e, closest[i])) closest[i] = e;
                if (closest[j] == null || less(e, closest[j])) closest[j] = e;
            }

            // add newly discovered edges to MST
            for (int i = 0; i < G.V(); i++) {
                Edge e = closest[i];
                if (e != null) {
                    int v = e.either(), w = e.other(v);
                    // don't add the same edge twice
                    if (!uf.connected(v, w)) {
                        mst.add(e);
                        weight += e.weight();
                        uf.union(v, w);
                    }
                }
            }
        }

        // check optimality conditions
        assert check(G);
    }

    /**
     * Returns the edges in a minimum spanning tree (or forest).
     * @return the edges in a minimum spanning tree (or forest) as
     *    an iterable of edges
     */
    public Iterable<Edge> edges() {
        return mst;
    }


    /**
     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
     * @return the sum of the edge weights in a minimum spanning tree (or forest)
     */
    public double weight() {
        return weight;
    }

    // is the weight of edge e strictly less than that of edge f?
    private static boolean less(Edge e, Edge f) {
        return e.weight() < f.weight();
    }

    // check optimality conditions (takes time proportional to E V lg* V)
    private boolean check(EdgeWeightedGraph G) {

        // check weight
        double totalWeight = 0.0;
        for (Edge e : edges()) {
            totalWeight += e.weight();
        }
        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
            return false;
        }

        // check that it is acyclic
        UF uf = new UF(G.V());
        for (Edge e : edges()) {
            int v = e.either(), w = e.other(v);
            if (uf.connected(v, w)) {
                System.err.println("Not a forest");
                return false;
            }
            uf.union(v, w);
        }

        // check that it is a spanning forest
        for (Edge e : G.edges()) {
            int v = e.either(), w = e.other(v);
            if (!uf.connected(v, w)) {
                System.err.println("Not a spanning forest");
                return false;
            }
        }

        // check that it is a minimal spanning forest (cut optimality conditions)
        for (Edge e : edges()) {

            // all edges in MST except e
            uf = new UF(G.V());
            for (Edge f : mst) {
                int x = f.either(), y = f.other(x);
                if (f != e) uf.union(x, y);
            }

            // check that e is min weight edge in crossing cut
            for (Edge f : G.edges()) {
                int x = f.either(), y = f.other(x);
                if (!uf.connected(x, y)) {
                    if (f.weight() < e.weight()) {
                        System.err.println("Edge " + f + " violates cut optimality conditions");
                        return false;
                    }
                }
            }

        }

        return true;
    }
}
```

# 最短路径

## 一、最短路径的性质

给定一幅==加权有向图==和一个顶点`s`，以`s`为起点的一棵最短路径树是图的一幅子图，它包含`s`和从`s`可达的所有顶点，这棵有向树的根结点为`s`，树的每条路径都是有向图中的一条最短路径。

这棵树一定是存在的，一般来说，从`s`到一个顶点有可能存在两条长度相等路径，如果出现这种问题，可以删除其中一条路径的最后一条边，直到从起点到每个顶点都只有一条路径相连。

## 二、数据结构

![加权有向图结构](img\加权有向图结构.jpg)

```java
/**
 * 加权有向边
 */
public class DirectedEdge {
    private final int src; // 起点
    private final int dst; // 终点
    private final double weight; // 权重

    public DirectedEdge(int src, int dst, double weight) {
        this.src = src;
        this.dst = dst;
        this.weight = weight;
    }

    public double getWeight() {
        return weight;
    }

    public int from(){
        return src;
    }

    public int to(){
        return dst;
    }

    @Override
    public String toString() {
        return String.format("%d->%d %.2f",src,dst,weight);
    }
}
```

```java
/**
 * 加权有向图
 */
public class EdgeWeightedDigraph {
    private  int V;
    private int E;
    private Bag<DirectedEdge>[] adj;

    public EdgeWeightedDigraph(int v) {
        init(v);
    }

    public EdgeWeightedDigraph(File file) {
        ByteBuffer bBuffer = ByteBuffer.allocateDirect(186140);
        StringBuffer sBuffer = new StringBuffer(186140);
        if (file == null) {
            return;
        }

        try (FileInputStream in = new FileInputStream(file); FileChannel channel = in.getChannel()) {
            CharBuffer charBuffer = null;
            Charset charset = Charset.forName("UTF-8");
            while (channel.read(bBuffer) != -1) {
                bBuffer.flip();
                charBuffer = charset.decode(bBuffer);
                sBuffer.append(charBuffer.toString());
                bBuffer.clear();
            }
            String content = sBuffer.toString();
            String[] contents = content.split("\\r\\n");
            int V = Integer.parseInt(contents[0]); // 顶点数
            init(V);
            String[] data;
            int v;
            int w;
            double weight;
            for (int i = 1; i < contents.length; i++) {
                data = contents[i].split("\\s+");
                v = Integer.parseInt(data[0]); // 起点
                w = Integer.parseInt(data[1]); // 终点
                weight = Double.parseDouble(data[2]); // 权重
                addEdge(new DirectedEdge(v, w, weight));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int init(int v) {
        this.V = v;
        this.E = 0;
        adj = new Bag[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new Bag<>();
        }
        return V;
    }

    public int V(){
        return V;
    }

    public int E(){
        return E;
    }

    public void addEdge(DirectedEdge e){
        adj[e.from()].add(e);
        E++;
    }

    public Iterable<DirectedEdge> adj(int v){
        return adj[v];
    }

    public Iterable<DirectedEdge> edges(){
        Bag<DirectedEdge> list = new Bag<>();
        for(int i = 0; i < V; i++){
            for(DirectedEdge e : adj(i)){
                list.add(e);
            }
        }
        return list;
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " " + E + "\n");
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (DirectedEdge e : adj[v]) {
                s.append(e + "  ");
            }
            s.append("\n");
        }
        return s.toString();
    }
}
```

## 三、最短路径算法的理论基础

### 1.边的松弛

松弛边`v->w`意味着检查从`s`到`w`的最短路径是否是先从`s`到`v`，然后再从`v`到`w`。如果是则更新相关数据结构的内容。

松弛顶点则意味着松弛与该顶点相连的所有边。

### 2.最优性条件

`G`为一幅加权有向图，顶点`s`是起点，`distTo[]`是一个由顶点索引的数组，保存的是`G`中路径的长度。对于从`s`可达的所有顶点`v`，`distTo[v]`是从`s`到`v`的某条路径的长度；对于从`s`不可达的顶点`v`，`distTo[v]`为无穷大。当且仅当对于从`w`到`v`的任意一条边`e`，`distTo[v]`都满足`distTo[v] <= distTo[w] + e.weight()` 时，`distTo[v]`是从`s`到`v`的最短路径长度。

最优性条件是的重要应用是最短路径的验证。

### 3.通用最短路径算法

将`distTo[s]`初始化为0，其他`distTo[]`元素初始化为无穷大。重复操作：松弛`G`中的任意边，直到所有`distTo[v]`都满足最优性条件。

## 四、Dijkstra 算法

Dijkstra 算法能够解决的是==权重非负==的加权有向图的单一起点最短路径问题。

### 1.思想

首先将`distTo[s]`初始化为0，其他`distTo[]`元素初始化为无穷大。然后松弛`distTo[]`中最小的非最短路径树顶点并且加入树中，重复这个操作，直到所有的顶点都在树中或者所有的非树顶点的`distTo[]`值均为无穷大。

将 Dijkstra 算法和 Prim 进行比较会比较好理解：Prim 算法每次添加的都是离最小生成树最近的非树顶点，Dijkstra 算法每次添加的都是离起点最近的非最短路径树顶点。

### 2.实现

需要用到的数据结构：

- `edgeTo[]`：`edegTo[v]`的值是从`s`到`v`的最短路径上的最后一条边
- `distTo[]`：`distTo[v]`是从`s`到`v`的已知最短路径长度
- 优先队列`pq`：保存需要被松弛的顶点并确认下一个被松弛的顶点

```java
public class DijkstraSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;
    private IndexMinPQ<Double> pq; // 优先队列中 v 的权值是 distTo[v]

    public DijkstraSP(EdgeWeightedDigraph G, int src) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];

        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }

        distTo[src] = 0.0;

        // relax vertices in order of distance from s
        pq = new IndexMinPQ(G.V());
        pq.insert(src, distTo[src]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            for (DirectedEdge e : G.adj(v)) {
                relax(e);
            }
        }
    }

    // 松弛边
    private void relax(DirectedEdge e) {
        int v = e.from();
        int w = e.to();
        if (distTo[w] > distTo[v] + e.getWeight()) {
            distTo[w] = distTo[v] + e.getWeight();
            edgeTo[w] = e;
            if (pq.contains(w)) {
                pq.decreaseKey(w, distTo[w]);
            } else {
                pq.insert(w, distTo[w]);
            }
        }
    }

    // 从起点到顶点 v 的最短路径长度
    public double distTo(int v) {
        return distTo[v];
    }

    // 顶点 v 是否可达
    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY; // 到 v 的距离小于无穷大就是可达
    }

    // 到 v 的最短路径的边序列
    public Iterable<DirectedEdge> pathTo(int v) {
        if (!hasPathTo(v)) {
            return null;
        }
        Stack<DirectedEdge> path = new Stack<>();
        // 这里是按照从 v 到 s 的顺序遍历边
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }
}
```

## 五、无环加权有向图的最短路径算法

### 1.思想

按照顶点拓扑排序后的顺序依次松弛每个顶点。

![无环图的最短路径算法](img\无环图的最短路径算法.jpg)

### 2.性能

- 能够在线性时间内处理单点最短路径问题
- 能够处理==负权重==的边

在已知图是无环图的情况下，这个算法已经是最快的最短路径算法。

### 3.实现

````java
/**
 *无环加权有向图最短路径
 */
public class AcyclicSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;

    public AcyclicSP(EdgeWeightedDigraph g,int src) {
        edgeTo = new DirectedEdge[g.V()];
        distTo = new double[g.V()];

        for (int i = 0; i < g.V(); i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        distTo[src] = 0.0;

        // 先拓扑排序，然后按照拓扑顺序松弛每个顶点
        TopologicalDG topo = new TopologicalDG(g);
        for(int v : topo.order()){
            for (DirectedEdge e : g.adj(v)){
                relax(e);
            }
        }
    }

    // 松弛边
    private void relax(DirectedEdge e) {
        int v = e.from(), w = e.to();
        if (distTo[w] > distTo[v] + e.getWeight()) {
            distTo[w] = distTo[v] + e.getWeight();
            edgeTo[w] = e;
        }
    }

    public double distTo(int v){
        return distTo[v];
    }

    public boolean hasPathTo(int v){
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Stack<DirectedEdge> path = new Stack<>();
        for(DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]){
            path.push(e);
        }
        return path;
    }
}
````

### 4.延伸

（1）在无环加权有向图中寻找最长路径

把`distTo[]` 的值初始化为负无穷，然后改变`relax`方法中不等号的方向。

（2）并行任务调度

给定一组需要按照优先级限制先后完成的任务，在满足限制条件的前提下应该如何在若干相同的处理器上（数量不限）安排任务并在最短的时间内完成？

解决这个问题的思路如下：

创建一幅无环加权有向图，其中包含一个起点和一个终点。每个任务都对应着一个起始顶点和一个结束顶点，这两个顶点之间的边的长度代表任务耗时。对于优先级限制`v->w`，就添加一条从任务`v`的结束顶点指向任务`w`的起始顶点的权重为0的边。除此之外，还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为0的边，以及一条从任务的结束顶点指向重点的权重为0的边。这样，每个任务的预计开始时间就是从起点到它的起始顶点的最长距离。

![并行任务调度](img\并行任务调度.jpg)

## 六、一般加权有向图的最短路径算法

### 1.前提

> 加权有向图中的负权重环是一个总权重（环上的所有边的权重之和）为负的有向环

假设从`s`到某个可达顶点`v`的路径上的某顶点在一个负权重环上，那么在这种情况下，最短路径是不存在的，因为只要沿着这个负权重环不停地绕圈子，就可以构造出权重任意小的路径。

因此，当且仅当加权有向图中至少存在一条从`s`到`v`的有向路径，并且路径上的所有顶点都不在任何负权重环汇总时，最短路径才有可能存在。

一般加权有向图的最短路径算法要能满足：

- 对于从起点不可达的顶点，最短路径为正无穷
- 对于从起点可达但路径上的某个顶点属于一个负权重环的顶点，最短路径为负无穷
- 对于其他的所有顶点，计算出最短路径（及其权重）

### 2.Bellman-Ford 算法

（1）思想

在任意含有$V$个顶点的加权有向图中给定起点`s`，==从`s`无法到达任何负权重环==。将`distTo[s]`初始化为0，其他`distTo[]`元素初始化为无穷大。以任意顺序松弛所有边，重复$V$轮。

（2）实现

- 首先将起点加入队列，然后进入一个循环，其中每次都从队列中取出一个顶点并将其放松。算法在$V$轮之后能够结束，可以显式计数，也可以在检测到负权重环之后结束。
- 队列中不能出现重复的顶点
- 在某一轮中，改变了`edgeTo[]`和`distTo[]`的值的所有顶点都会在下一轮中处理

```java
public class BellmanFordSP {
    private double[] distTo;               // distTo[v] = distance  of shortest s->v path
    private DirectedEdge[] edgeTo;         // edgeTo[v] = last edge on shortest s->v path
    private boolean[] onQueue;             // onQueue[v] = is v currently on the queue?
    private Queue<Integer> queue;          // queue of vertices to relax
    private int cost;                      // number of calls to relax()
    private Iterable<DirectedEdge> cycle;  // negative cycle (or null if no such cycle)

    /**
     * Computes a shortest paths tree from {@code s} to every other vertex in
     * the edge-weighted digraph {@code G}.
     * @param G the acyclic digraph
     * @param s the source vertex
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public BellmanFordSP(EdgeWeightedDigraph G, int s) {
        distTo  = new double[G.V()];
        edgeTo  = new DirectedEdge[G.V()];
        onQueue = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // Bellman-Ford algorithm
        queue = new Queue<Integer>();
        queue.enqueue(s);
        onQueue[s] = true;
        while (!queue.isEmpty() && !hasNegativeCycle()) {
            int v = queue.dequeue();
            onQueue[v] = false;
            relax(G, v);
        }

        assert check(G, s);
    }

    // relax vertex v and put other endpoints on queue if changed
    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.getWeight()) {
                distTo[w] = distTo[v] + e.getWeight();
                edgeTo[w] = e;
                if (!onQueue[w]) {
                    queue.enqueue(w);
                    onQueue[w] = true;
                }
            }
            // find a negative cycle periodically
            if (cost++ % G.V() == 0) {
                findNegativeCycle();
                if (hasNegativeCycle()) return;  // found a negative cycle
            }
        }
    }

    /**
     * Is there a negative cycle reachable from the source vertex {@code s}?
     * @return {@code true} if there is a negative cycle reachable from the
     *    source vertex {@code s}, and {@code false} otherwise
     */
    public boolean hasNegativeCycle() {
        return cycle != null;
    }

    /**
     * Returns a negative cycle reachable from the source vertex {@code s}, or {@code null}
     * if there is no such cycle.
     * @return a negative cycle reachable from the soruce vertex {@code s}
     *    as an iterable of edges, and {@code null} if there is no such cycle
     */
    public Iterable<DirectedEdge> negativeCycle() {
        return cycle;
    }

    // by finding a cycle in predecessor graph
    private void findNegativeCycle() {
        int V = edgeTo.length;
        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
        for (int v = 0; v < V; v++)
            if (edgeTo[v] != null)
                spt.addEdge(edgeTo[v]);

        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
        cycle = finder.cycle();
    }

    /**
     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
     *         {@code Double.POSITIVE_INFINITY} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *         from the source vertex {@code s}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        validateVertex(v);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        return distTo[v];
    }

    /**
     * Is there a path from the source {@code s} to vertex {@code v}?
     * @param  v the destination vertex
     * @return {@code true} if there is a path from the source vertex
     *         {@code s} to vertex {@code v}, and {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        validateVertex(v);
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path from the source {@code s} to vertex {@code v}.
     * @param  v the destination vertex
     * @return a shortest path from the source {@code s} to vertex {@code v}
     *         as an iterable of edges, and {@code null} if no such path
     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
     *         from the source vertex {@code s}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<DirectedEdge> pathTo(int v) {
        validateVertex(v);
        if (hasNegativeCycle())
            throw new UnsupportedOperationException("Negative cost cycle exists");
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
            path.push(e);
        }
        return path;
    }

    // check optimality conditions: either
    // (i) there exists a negative cycle reacheable from s
    //     or
    // (ii)  for all edges e = v->w:            distTo[w] <= distTo[v] + e.weight()
    // (ii') for all edges e = v->w on the SPT: distTo[w] == distTo[v] + e.weight()
    private boolean check(EdgeWeightedDigraph G, int s) {

        // has a negative cycle
        if (hasNegativeCycle()) {
            double weight = 0.0;
            for (DirectedEdge e : negativeCycle()) {
                weight += e.getWeight();
            }
            if (weight >= 0.0) {
                System.err.println("error: weight of negative cycle = " + weight);
                return false;
            }
        }

        // no negative cycle reachable from source
        else {

            // check that distTo[v] and edgeTo[v] are consistent
            if (distTo[s] != 0.0 || edgeTo[s] != null) {
                System.err.println("distanceTo[s] and edgeTo[s] inconsistent");
                return false;
            }
            for (int v = 0; v < G.V(); v++) {
                if (v == s) continue;
                if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
                    System.err.println("distTo[] and edgeTo[] inconsistent");
                    return false;
                }
            }

            // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
            for (int v = 0; v < G.V(); v++) {
                for (DirectedEdge e : G.adj(v)) {
                    int w = e.to();
                    if (distTo[v] + e.getWeight() < distTo[w]) {
                        System.err.println("edge " + e + " not relaxed");
                        return false;
                    }
                }
            }

            // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
            for (int w = 0; w < G.V(); w++) {
                if (edgeTo[w] == null) continue;
                DirectedEdge e = edgeTo[w];
                int v = e.from();
                if (w != e.to()) return false;
                if (distTo[v] + e.getWeight() != distTo[w]) {
                    System.err.println("edge " + e + " on shortest path not tight");
                    return false;
                }
            }
        }

        System.out.println("Satisfies optimality conditions");
        System.out.println();
        return true;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        int V = distTo.length;
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }
}
```

## 习题

### 1.如何在加权无向图中找最短路径（假设权值均为正）？

根据给定的无向图构造出一幅有向图，无向图的每条边都对应着有向图中两条方向相反的边，然后执行 Dijkstra 算法。

### 2.给定一幅无向图，除了起点和终点外所有的顶点的度都为2，设计一个线性时间内运行的算法，计算出任意两个顶点之间的最短路径

从起点（或终点）开始遍历顶点（深度优先或者广度优先），遍历的过程中计算从起点（或终点）到每个顶点的路径长度，记为`dist[]`，那么顶点`v`和`w`之间的最短路径长度就是$|dist[v]-dist[w]|$。

